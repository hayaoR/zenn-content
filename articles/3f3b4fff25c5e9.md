---
title: "Rustの非同期をあっさり整理する"
emoji: "👌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust"]
published: false
---

# はじめに
自分の理解の整理も兼ねてRustの非同期を整理してみます。Rust初心者かつIT初心者などで誤りなどが多分に含まれていると思います。

## taskとexecutor
Rustの非同期には2つの主要概念があります。taskとexecutorです。taskは処理の単位です。
taskは`tokio::spawn`で起動されます。
関数宣言を見ればわかりますが、tokio::spawnは`Future`トレイトの実装を要求します。(`Send`と`'static`も要求しますが、その訳は省略します。)
`Future`トレイトについては`Future`セクションをご覧ください。
taskの実行はexecutorによって管理されます。
executorはtaskの実行を管理するひとです。
管理の方法はwakerとcontextを参照ください。
executorは`tokio::runtime::Runtime`の`block_on`関数で起動します。
ただ、非同期処理の例を見ると以下のようなコードで`block_on`関数が見当たらないものがあります。
これは`#[tokio::main]`というマクロが付与されていることに注目してください。このマクロが展開されると以下のようになるらしいです。


//TODO tokio::spawnのコード例 

//TODO #[tokio::main]のコード例


## Future
Futureトレイトは以下のように定義されています。
おいおい、`Pin<&mut self>`ってなんやねん。。という方はPinセクションを見てください。
イメージ的にはまだ計算が終わっていないかもしれない値だと思ってください。`poll`関数を呼ぶことで処理を進めようとします。
`poll`関数はそのfututeがまだ準備ができていなければ`Poll::Pending`、準備ができていれば`Poll::Ready`を返します。
`poll`関数はすぐに値を返すことが期待されています。ブロックすべきではありません。
executorはtask群のpollをいい感じに呼び出すことで処理を進めていきます。
ではどうやっていい感じに進めるのでしょうか？それがContextとwakerの仕事です。
`poll`関数はContextを引数に取れることが分かると思います。ExecutorはtaskにContextを渡して、そのtaskが再度処理を進めることができるという段階でそのcontextからwakerを取得してwake関数を呼んでもらうことを期待します。

## IOイベントとwake

## async/awaitとgenerotor
pollの実装としては手動でステートマシンを実装するというのが考えられます。コード例を以下に示します。こんなの実装したくないですよね。。
他に策はないのでしょうか？安心してください。あります。Rustは`async/await`という機構を提供しています。
async関数はジェネレータに変換されて、ジェネレータがステートマシンに変換されます。

ジェネレータは再開可能な計算です。計算が再開可能であるためには中断地点での情報を保持しておく必要があります。
ここで問題点が発生します。以下のような状況でジェネレータが移動したらどうなるでしょう？
ダングリングポインタが発生してしまいます。
この問題の対応として考えられたのが`Pin`です。

//TODO pollの実装　ステートマシン 

//TODO async/awaitのコード例

//TODO ジェネレータのコード例

//TODO 自己参照構造体の移動の例　図を書く

## pin
Pinはその背後の値をムーブさせないための型です。Pinを作るにはその値の所有権を渡さなければ行けない、かつsafe RustでPinから可変参照を取ることができないので、Pinに渡された値をムーブさせることができません。
ジェネレータが保持するデータ構造は最初にyeildが呼ばれるまではつくられないので、Pin止めしてからpollを呼べば良いというわけです。

### pin project
SelfはPin止めされていますが、poll無いでSelfをアクセスしたいことがあると思います。セルフが持っているFutureをpollするなど、そんな操作を簡単にするのが`pin_project`クレートです。

//TODO 具体例