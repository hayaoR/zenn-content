---
title: "Rustの非同期をあっさり整理する"
emoji: "👌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust"]
published: false
---

# はじめに
自分の理解の整理も兼ねてRustの非同期を整理してみます。Rust初心者かつIT初心者などで誤りなどが多分に含まれていると思います。誤りはコメントでご指摘いただけると助かります。


## taskとexecutor
Rustの非同期には2つの主要概念があります。`task`と`executor`です。

### task
`task`は処理の単位です。
`task`は`tokio::spawn`で起動されます。
`spaen`のシグネチャを見ればわかりますが、`tokio::spawn`は`Future`トレイトの実装を要求します。(`Send`と`'static`も要求しますが、その理由は省略します。)
`Future`トレイトについては`Future`セクションをご覧ください。
`task`の実行は`executor`によって管理されます。

```rust:spawnのシグネチャ
pub fn spawn<T>(future: T) -> JoinHandle<T::Output>
where
    T: Future + Send + 'static,
    T::Output: Send + 'static, 
```

```rust:spawnのコード例 
use tokio::net::{TcpListener, TcpStream};

use std::io;

async fn process(socket: TcpStream) {
    // ...
}

#[tokio::main]
async fn main() -> io::Result<()> {
    let listener = TcpListener::bind("127.0.0.1:8080").await?;

    loop {
        let (socket, _) = listener.accept().await?;

        tokio::spawn(async move {
            // Process each socket concurrently.
            process(socket).await
        });
    }
}
```
引用[^1]

### executor
`executor`は`task`の実行を管理するものです。
管理の方法はContextセクションを参照ください。
`executor`は`tokio::runtime::Runtime`の`block_on`関数で起動します。
ただ、非同期処理の例を見ると以下のようなコードで`block_on`関数が見当たらないものが多いです。
`#[tokio::main]`というマクロが付与されていることに注目してください。このマクロが展開されると以下のようになるらしいです。


```rust:非同期関数の例
#[tokio::main]
async fn main() {
    println!("hello");
}
```

```rust:非同期関数の例(展開後)
fn main() {
    let mut rt = tokio::runtime::Runtime::new().unwrap();
    rt.block_on(async {
        println!("hello");
    })
}
```
引用[^2]



## Future
`Future`トレイトは以下のように定義されています。
(おいおい、`Pin<&mut self>`ってなんやねん。。という方はPinセクションを見てください。)

```rust
pub trait Future {
    type Output;
    Fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

`Future`はイメージ的にはまだ計算が終わっていないかもしれない値だと思ってください。`poll`関数を呼ぶことで処理を進めようとします。

:::message
「Futureは～」という表現は「Futureを実装した任意の値は～」という意味だと解釈してください。
:::

`poll`関数はその`Futute`がまだ準備ができていなければ`Poll::Pending`、準備ができていれば`Poll::Ready(T)`を返します。
`poll`関数はすぐに値を返すことが期待されています。ブロックすべきではありません。なぜなら`poll`が処理をブロックしてしまうと、その`Future`を実行しているスレッドがブロックされてしまうからです。
`executor`は`task`群の`poll`をいい感じに呼び出すことで処理を進めていきます。
ではどうやっていい感じに進めるのでしょうか？それが`Context`の役割です。

### Context
`poll`関数は`Context`を引数に取れることが分かると思います。`executor`は`task`に`Context`を渡して、その`task`が再度処理を進めることができるという段階でその`Context`から`waker`を取得して`wake`関数を呼んでもらうことを期待します。
例えばWebサーバーがリスン状態でクライアントからの接続を待ち受けていて、クライアントからのリクエストがあったときに`wake`を呼び出すなどが考えられます。
ただこのような処理は大体用意されているので、一般ユーザが`wake`を呼ぶ機会がどれだけあるのかは良く分かっていません。。


## async/await
`Future`トレイトを実装するには`poll`を実装しなければいけないことが分かったと思いますが、どう実装するのでしょうか？
`poll`の実装としては手動でステートマシンを実装するというのが考えられます。ただ手動でステートマシンを実装するって嫌ですよね。。
他に策はないのでしょうか？安心してください。あります。Rustは`async/await`という機構を提供しています。
関数に`async`をつけるとその関数が`Future`を返すようになります。また`async`関数内では任意の`Future`に`await`を呼ぶことができます。
`async`関数は`generator`に変換されて、`generator`がステートマシンに変換されます。

## generator
`generator`は再開可能な計算です。関数内で`yield`を呼ぶことで呼び元に制御を戻すことができます。Python民には馴染み深いかもしれません。計算が再開可能であるためには中断地点での情報を保持しておく必要があります。
ここで問題が発生します。以下のような状況で`generator`が移動したらどうなるでしょう？
ダングリングポインタが発生してしまいます。
この問題の対応として考えられたのが`Pin`です。

//TODO 自己参照構造体の移動の例　図を書く

## Pin
`Pin`はその背後の値をムーブさせないための型です。`Pin`を作るにはその値の所有権を渡さなければいけない、かつSafe Rustで`Pin`から可変参照を取ることができないので、`Pin`に渡された値をムーブさせることができません。
`generator`が保持するデータ構造は最初に`yield`が呼ばれるまではつくられないので、それまでは値をムーブしても問題ありません、したがって、まずPin止めをして(ムーブしますが、前述の理由により問題ありません)、それから`poll`を呼べば、その後値がムーブされることは無いという訳です。

### pin_project
SelfはPin止めされていますが、`poll`でSelfをアクセスしたいことがあると思います(selfが持っている`Future`を`poll`するなど)。そんな操作を簡単にするのが`pin_project`クレートです。
使い方はドキュメント[^3]を参照ください。

# 参考文献

- https://tokio.rs/tokio/tutorial
- https://www.oreilly.co.jp/books/9784873119786/
- https://nostarch.com/rust-rustaceans


[^1]:https://docs.rs/tokio/latest/tokio/fn.spawn.html
[^2]:https://tokio.rs/tokio/tutorial/hello-tokio
[^3]:https://docs.rs/pin-project/latest/pin_project/