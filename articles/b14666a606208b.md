---
title: "AxumでOpenID Connectクライアントを実装してみた"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust"]
published: false
---

# はじめに
Axumで練習でなんかアプリ作ってみたいなと思いました。
まずはログイン機能を実装したいと思った時に、Basic認証orOpenID Connectになるのかと思いました。

セキュアなBasic認証を実装するのは非常に難しいらしいのでOpenID Connectを実装使用と決めました。

この記事ではAxum+openidクレートで実装したサンプルコードを見ながらOIDCクライアントの動作について解説したいと思います。
なおこのコードはwarp+openidクレートで実装したコードを基に実装しました。

# Open ID Connectのシーケンス図
まずそもそもOpen ID Connectってなに？という人は以下の[記事](https://qiita.com/TakahikoKawasaki/items/498ca08bbfcc341691fe)を御覧ください。
まずシーケンス図を示します。
このシーケンス図で振った番号と実際のコードを突き合わせながら解説していきたいと思います。

# 前提
このOpenIdクライアントはGoogle OpenId Connectで動作を試してみました。動作させるには事前にクライアントIDとクライアントシークレットを入手し環境変数に設定させる必要があります。またリダイレクトURLの登録も必要です。

# 登場人物

## ブラウザ
ブラウザはクライアントに自分が誰なのかを証明したいです。

## クライアント
クライアントは例えばショッピングサイトでブラウザが誰なのかを知りたいです。

## IdP
IdPはブラウザは〇〇やでとクライアントに教えてくれる人です。


# 1.ディスカバリ
最終的にIdPから受け取るIDトークンは署名されているので、その署名の検証に必要な情報をIdPから事前に取得しています。JWKセット文書と呼ばれているみたいでず。
その値はopenidクレートで定義されているClient構造体に保持されます。
```rust
#[tokio::main]
async fn main() {
    let client_id = std::env::var("CLIENT_ID").expect("Unspecified CLIENT_ID as env var");
    let client_secret =
        std::env::var("CLIENT_SECRET").expect("Unspecified CLIENT_SECRET as env var");
    let issuer_url = std::env::var("ISSURE").unwrap_or("https://accounts.google.com".to_string());
    let redirect = Some(host("/login/oauth2/code/oidc"));
    let issuer = reqwest::Url::parse(&issuer_url).unwrap();

    let client = Arc::new(
        DiscoveredClient::discover(client_id, client_secret, redirect, issuer)
            .await
            .unwrap(), // ディスカバリ
    );
    //....
}
```

```rust:Client構造体
#[derive(Debug)]
pub struct Client<P = Discovered, C: CompactJson + Claims = StandardClaims> {
    /// OAuth provider.
    pub provider: P,

    /// Client ID.
    pub client_id: String,

    /// Client secret.
    pub client_secret: String,

    /// Redirect URI.
    pub redirect_uri: Option<String>,

    pub http_client: reqwest::Client,

    pub jwks: Option<JWKSet<Empty>>,
    marker: PhantomData<C>,
}

```
https://github.com/kilork/openid から引用

# 2.認可リクエスト
認可リクエストは大雑把にいうとクライアントがユーザーに「IdPにお前がだれか証明してな」と言って、IdPにリダイレクトさせるリクエストです。
認証が成功すると認可リクエストで設定しておいたリダイレクトエンドポイントにコード値をもってブラウザがリダイレクトされます。

```rust
pub async fn authorize(
    Extension(oidc_client): Extension<Arc<OpenIDClient>>, // oidc_clientはディスカバリで生成したClient構造体
) -> (StatusCode, HeaderMap) {
    let origin_url = std::env::var("ORIGIN").unwrap_or(host(""));
    let auth_url = oidc_client.auth_url(&Options {
        scope: Some("openid email profile".into()),
        state: Some(origin_url),
        ..Default::default()
    });
    let url = String::from(auth_url);

    let mut headers = HeaderMap::new();
    let val = if let Ok(val) = HeaderValue::from_str(&url) {
        val
    } else {
        return (StatusCode::INTERNAL_SERVER_ERROR, headers);
    };
    headers.insert(http::header::LOCATION, val);

    (StatusCode::FOUND, headers)
}
```

ここはurlを生成して、ブラウザにリダイレクトさせるレスポンスを返すという感じですね。

# 3.トークンリクエスト
この時点でクライアントはcode、client_id、client_secret、redirect_urlを持っているのでそれを使ってトークンリクエストを発行します、そうするとIdPからアクセストークンとIDトークンを手に入れることができます。

```rust
pub async fn login(
    Extension(oidc_client): Extension<Arc<OpenIDClient>>,
    login_query: Query<LoginQuery>, //クエリパラメータのcode値を取得
) -> impl IntoResponse {
    let request_token = request_token(oidc_client, &login_query).await;
    match request_token {
        Ok(Some((token, user_info))) => {
            let login = user_info.preferred_username.clone();
            let email = user_info.email.clone();

            let user = User {
                id: user_info.sub.clone().unwrap_or_default(),
                login,
                last_name: user_info.family_name.clone(),
                first_name: user_info.name.clone(),
                email,
                activated: user_info.email_verified,
                image_url: user_info.picture.clone().map(|x| x.to_string()),
                lang_key: Some("en".to_string()),
                authorities: vec!["ROLE_USER".to_string()],
            };
            //....
    }
}

async fn request_token(
    oidc_client: Arc<OpenIDClient>,
    login_query: &LoginQuery,
) -> anyhow::Result<Option<(Token, Userinfo)>> {
    let mut token: Token = oidc_client.request_token(&login_query.code).await?.into(); // トークンリクエスト

    if let Some(mut id_token) = token.id_token.as_mut() {
        oidc_client.decode_token(&mut id_token)?; //トークンをデコード
        oidc_client.validate_token(&id_token, None, None)?; //　トークンをバリデート
    } else {
        return Ok(None);
    }

    let userinfo = oidc_client.request_userinfo(&token).await?;

    Ok(Some((token, userinfo)))
}
```


# 所感
warp+openidのコードをaxum+openidのコードに変換するくらい楽勝やろ！と思っていましたが、warpもAxumもよく知らないということもあってスムーズには行きませんでした。ただ実際にコードリーディングをすると、OpenID Connectの説明をただ読むよりも理解がました気がするので実際のコードを見てみるというやりかたは何かを習得する方法として有効なのかなと感じました。
またクレートを使うと比較的シンプルですが、クレート内ではややこしいことをやっていて、oidcクライアントの処理をスクラッチで実装するのは避けたほうがいいなと感じました。


