---
title: "RustのResult<T, E>のEって何にする？"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust"]
published: false
---

# 結論
よくわからなければ`anyhow::Error`にしておくのがよさそう。

:::message alert
2021/11現在 Rustのエラーハンドリングのベストプラクティスというのは定まっていないようです。
なのでこれからRustのエラーハンドリングがどうなっていくのかは注視する必要があるでしょう。
:::

# Rustのエラーハンドリングのキホン
Rustを勉強していくとエラーハンドリングは`Result<T, E>`を使うということが分かります。
`Result<T, E>`を返す関数内では`?`演算子が使えて

このコードが
```rust
use std::fs::OpenOptions;
use std::io;
use std::io::prelude::*;
use std::path::Path;

fn write(filename: impl AsRef<Path>) -> Result<(), io::Error> {
    let mut file = match OpenOptions::new().write(true).open(filename) {
        Ok(file) => file,
        Err(e) => return Err(From::from(e)), // このコードでFrom::fromは不要ですが、?の動作のdesugarを表現するために書いています。
    };
    match file.write_all(b"Hello, world!") {
        Ok(ok) => ok,
        Err(e) => return Err(From::from(e)),
    };
    Ok(())
}
```

このように書き換えることができます。

```rust
use std::fs::OpenOptions;
use std::io;
use std::io::prelude::*;
use std::path::Path;

fn write(filename: impl AsRef<Path>) -> Result<(), io::Error> {
    let mut file = OpenOptions::new().write(true).open(filename)?
    file.write_all(b"Hello, world!")?
    Ok(())
}
```

すばらしい。。「例外なんていらんかったんや！」と思うわけですが、以下のような疑問が浮かんできます。
- 階層を持つエラーはどうやってコンテキストを保つのか
- ある関数で複数の種類のエラーを返す場合どうしたらいいのか

まず最初の疑問から見ていきます。この疑問に答えるためには`Error`トレイトについて説明する必要があります。

# コンテキストの保持

## Errorトレイト
Rustには`Error`というトレイトがあります。以下のようなものです

```rust
pub trait Error: Debug + Display {
    fn source(&self) => Option<&(dyn Error + 'static)> {
        None
    }
}
```

私は最初勘違いしていたのですが、`Result<T, E>`は別にEが`Error`トレイトを実装することを要求してはいません。
ではこの`Error`トレイトはなんのために存在しているのでしょうか。

### Errorトレイトの役割

`Error`トレイトには3つの役割があるようです。
1. エラーのマーカー
2. 表示方法の提供
3. コンテクストの表現

#### エラーのマーカー
これは`Error`トレイトを実装している型はエラーであることを表現できるということです。

#### 表示方法
`Error`トレイトは`Debug`と`Display`の実装を要求しています。したがって`Error`トレイトを実装する構造体は例えば`println!("{}", e);`や`println!("{:?}", e);`とすればエラーを表示できます。

#### コンテクストの表現
`Error`トレイトは`source`メソッドをもっています。エラーがそのソースを持っていた場合`sorce`トレイトをオーバーライドします。
`Error`トレイトの[ドキュメント](https://doc.rust-lang.org/std/error/trait.Error.html)から使用例を引用します。

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct SuperError {
    side: SuperErrorSideKick,
}

impl fmt::Display for SuperError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "SuperError is here!")
    }
}

impl Error for SuperError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(&self.side)
    }
}

#[derive(Debug)]
struct SuperErrorSideKick;

impl fmt::Display for SuperErrorSideKick {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "SuperErrorSideKick is here!")
    }
}

impl Error for SuperErrorSideKick {}

fn get_super_error() -> Result<(), SuperError> {
    Err(SuperError { side: SuperErrorSideKick })
}

fn main() {
    match get_super_error() {
        Err(e) => {
            println!("Error: {}", e);
            println!("Caused by: {}", e.source().unwrap());
        }
        _ => println!("No error"),
    }
}
```

```bash:実行結果
Error: SuperError is here!
Caused by: SuperErrorSideKick is here!
```

`e.source()`を呼ぶことで下位のエラーを得ることができます。以下のように再帰的に`source`を呼べばエラーのコンテクストをプリントできます。

```rust
   let e = e.source();
   while let Some(cause) = e {
       println!("Caused by: {}", cause);
       e = cause.source();
   }
```


ただしこれはあまりにもミスするのが簡単なためもっと簡単にコンテクストをプリントできるようにしようとする動きがあるようです。
https://blog.rust-lang.org/inside-rust/2021/07/01/What-the-error-handling-project-group-is-working-towards.html


# 複数の種類のエラーを返す場合
次に2つめの疑問である。ある関数で複数の種類のエラーを返す場合どうしたらいいのかについて見ていきます。
これには2種類の手法があるようです。`Enum`を使う方法と`Box`を使う方法です。

## Enum
１つ目の手法はEnumを使う方法です。例として`sqlx::Error`の抜粋を示します。

```rust
pub enum Error {
    /// Error occurred while parsing a connection string.
    Configuration(BoxDynError),

    /// Error returned from the database.
    Database(Box<dyn DatabaseError>),

    /// Error communicating with the database backend.
    Io(io::Error),

    Tls(BoxDynError),

    ///.....省略
}
```
https://github.com/launchbadge/sqlx/blob/master/sqlx-core/src/error.rs から改変・抜粋して引用

このようにエラーを定義して、Enumの構成要素それぞれに対して`From`トレイトを実装すれば'?'オペラータを使って、複数のエラーを扱うことができます。

```rust:Fromトレイトの実装例
impl From<io::Error> for Error {
    fn from(e: io::Error) -> Self {
        Self::Io(e)
    }
}
```

さらにこの`Error`をエラーにするためには`Error`トレイトの実装をしなければなりません。`Debug`は自動導出できますが、`Display`は手で実装しなければなりません。
またエラーのソースを持っているので`source`関数もオーバーライドしたほうがいいでしょう。
まとめると以下のような作業が必要です。

1. 各構成要素に`From`トレイトの実装
2. `Error`トレイトの実装(`source`関数の実装と`Display`トレイトの実装)

これは結構面倒な作業なのでマクロでこのようなボイラープレートを生成してくれる[thiserror](https://github.com/dtolnay/thiserror)というクレートが存在します。


### メリット
Enumでエラーをまとめることのメリットはパターンマッチングでその構成要素を取得できることでしょう。

### デメリット 
実装が若干面倒なことですかね。

## Box
もう一つの方法は`Box<dyn Error + Send + Sync + 'static>`を使うことでしょう。`Result<T, E>`のEを`Box<dyn Error + Send + Sync + 'static>`にしておけば、簡単に複数の種類のエラーに対処することができます。
`Box<dyn Error ...>`の強化版?として[anyhow](https://github.com/dtolnay/anyhow)というクレートがあります。


###　メリット 
実装が楽なことですかね。

### デメリット
詳細な値の取得が難しいことです。`downcast_ref`という関数で詳細の値を得ることは可能ですが、この関数を多用するようなら`Enum`でエラーを構成するほうがよいでしょう。


# まとめ
基本的には`Error`トレイトを実装したなにかを使ったほうがいいでしょう。(Box化されたエラーに変換できるので)
複数の種類のエラーが返される場合は`Enum`(`thiserror`)を使うか`Box`(`anyhow`)を使うかでしょう。
エラーの詳細の値を扱いたい場合は`Enum`、ただエラーを報告したいだけのときは`Box`を使うというのが定説みたいです。