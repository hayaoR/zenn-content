---
title: "RustのResult<T, E>のEって何にする？"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust"]
published: false
---

# 結論
よくわからなければ`anyhow::Error`にしておくのがよさそう。

:::message alert
2021/11現在 Rustのエラーハンドリングのベストプラクティスというのは定まっていないようです。
なのでこれからRustのエラーハンドリングがどうなっていくのかは注視する必要があるでしょう。
:::

# Rustのエラーハンドリングの基礎
Rustを勉強していくとエラーハンドリングは`Result<T, E>`を使うということが分かります。
`Result<T, E>`を返す関数内では`?`演算子が使えて

このコードが
```rust
use std::fs::OpenOptions;
use std::io;
use std::io::prelude::*;
use std::path::Path;

fn write(filename: impl AsRef<Path>) -> Result<(), io::Error> {
    let mut file = match OpenOptions::new().write(true).open(filename) {
        Ok(file) => file,
        Err(e) => return Err(From::from(e)), // このコードでFrom::fromは不要ですが、?の動作のdesugarを表現するために書いています。
    };
    match file.write_all(b"Hello, world!") {
        Ok(ok) => ok,
        Err(e) => return Err(From::from(e)),
    };
    Ok(())
}
```

このように書き換えることができます。

```rust
use std::fs::OpenOptions;
use std::io;
use std::io::prelude::*;
use std::path::Path;

fn write(filename: impl AsRef<Path>) -> Result<(), io::Error> {
    let mut file = OpenOptions::new().write(true).open(filename)?
    file.write_all(b"Hello, world!")?
    Ok(())
}
```

すばらしい。。「例外なんていらんかったんや！」と思うわけですが、以下のような疑問が浮かんできます。
- ある程度の階層を持つ関数でどうやってコンテキストを保ちながら呼び出し元にエラーを返すのか
- ある関数で複数の種類のエラーを返す場合どうしたらいいのか

まず最初の疑問から見ていきます。

# Errorトレイト
Rustには`Error`というトレイトがあります。以下のようなものです

```rust
pub trait Error: Debug + Display {
    fn source(&self) => Option<&(dyn Error + 'static)> {
        None
    }
}
```

私は最初勘違いしていたのですが、`Result<T, E>`は別にEが`Error`トレイトを実装することを要求してはいません。
ではこの`Error`トレイトはなんのために存在しているのかという話ですが、一番大きな理由はこのトレイトを実装している構造体はエラーを表しているということを表現するためでしょう。

`Error`トレイトで注目すべき点の１つは`Error`トレイトを実装する構造体に`Debug`トレイトと`Display`トレイトの実装を要求していることです。`Debug`は説明的で`derive`で自動導出できます。`Display`は自動導出できません。
`Error`トレイトを実装するために`Display`トレイトを実装する場合、何を誤ったかの1行の説明が好まれるようです。

`Error`トレイトは`source`メソッドをもっていますがこれはなんでしょうか？これは`Error`トレイトを実装するエラーの下に横たわるエラーを返すための関数です。
`Error`トレイトの[ドキュメント](https://doc.rust-lang.org/std/error/trait.Error.html)から使用例を引用します。

```rust
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct SuperError {
    side: SuperErrorSideKick,
}

impl fmt::Display for SuperError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "SuperError is here!")
    }
}

impl Error for SuperError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(&self.side)
    }
}

#[derive(Debug)]
struct SuperErrorSideKick;

impl fmt::Display for SuperErrorSideKick {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "SuperErrorSideKick is here!")
    }
}

impl Error for SuperErrorSideKick {}

fn get_super_error() -> Result<(), SuperError> {
    Err(SuperError { side: SuperErrorSideKick })
}

fn main() {
    match get_super_error() {
        Err(e) => {
            println!("Error: {}", e);
            println!("Caused by: {}", e.source().unwrap());
        }
        _ => println!("No error"),
    }
}
```

```bash:実行結果
Error: SuperError is here!
Caused by: SuperErrorSideKick is here!
```

`e.source()`を呼ぶことで下位のエラーを得ることができます。以下のように再帰的に`source`を呼べばエラーのコンテクストをプリントできます。

```rust
   let e = e.source();
   while let Some(cause) = e {
       println!("Caused by: {}", cause);
       e = cause.source();
   }
```

逆に下位のエラーのコンテクストを保持したければ`source`を適切に実装しなければなりません。

なので最初の疑問の答えとしては`source`を忘れずに呼びましょうということになります。ただしこれはあまりにもミスするのが簡単なためもっと簡単にコンテクストをプリントできるようにしようとする動きがあるようです。
https://blog.rust-lang.org/inside-rust/2021/07/01/What-the-error-handling-project-group-is-working-towards.html


# 複数の種類のエラーを返す場合
次に2つめの疑問である。ある関数で複数の種類のエラーを返す場合どうしたらいいのかについて見ていきます。
これには2種類の手法があるようです。`Enum`を使う方法と`Box`を使う方法です。

## Enum

## Box

# ライブラリの使用

## anyhow

## thiserror