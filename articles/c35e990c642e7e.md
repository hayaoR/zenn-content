---
title: "AxumでGoのチュートリアル「Writing Web Application」をやってみた"
emoji: "🦀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: []
published: false
---

# はじめに
私は現在プログラム初心者ですが、エンジニアとしてのスキルをこれから高めていきたいと思っています。
とりあえず、社会で比較的需要の多い、Webバックエンド開発の基礎を習得したいと思いました。
Webバックエンドのフレームワークは星の数ほどあれど、それらに共通した要素は多いはずで、それを習得してしまえば、新たなフレームワークを学ぶのは容易になると思ったので、まず１つのWebフレームワークについて習熟していきたいと思いました。
仕事と違い好きに選べるなら自分の好きな言語のフレームワークを選びたいということでAxumを選びました。
ただAxumは現在も活発に開発されている新しいフレームワークで、チュートリアルなどが見当たらないので、Goのnet/httpのチュートリアル「Writing Web Application」をAxumでやってみました。


# Axumとは
Axumは非常にスリムなフレームワークです。AxumはGitHubのREADMEに書かれているように**Ergonomics**と**Modularity**にフォーカスしています。

# Modularity
## 色々なクレートがレゴブロックのように組み合わされています。
たとえば非同期ランタイムは`tokio`、サーバーは`hyper`、Requestを受け取りResponseを返すものを抽象化したサービスは`tower`を用いられています。
作者はaxumは実際"tower::Serviceをルーティングするフレームワークである"と言っています。

# Ergonomics
Ergonomicsは人間工学という意味だそうです。使いやすさを重視しているということでしょう。
## 特徴
- マクロフリーなルーティング
Webフレームワークの中にはアノテーション(マクロ)でルーティングするWebフレームワークも多いですが、Axumはその方式は採用していません。
マクロは非常に高い表現力ゆえに、何をしているのか分かりづらいという側面があるので、Axumの作者はなるべく使用を避けようとしているのでしょう。
とはいえ、マクロは使いすぎなければ、非常に便利で効果的な機能なので、これは好みの問題も大きい気がします。

- 宣言的なリクエストとレスポンスのパース
Goのnet/httpやechoだとハンドラは、要求されたインターフェイスを実装した構造体に対して、操作を施し、リクエストからデータを抽出したりレスポンスを返したりしたりする方式を採用していますが、Axumではハンドラはリクエストは0個以上のExtractorを実装した型でレスポンスがIntoResponseを実装した型です。言葉だと分かりづらいので具体例で比較してみます。

# Gowiki
「Writing Web Application」はGowikiという超簡易的なWikiを作るチュートリアルです。
簡単のためWikiのページはファイルで管理されています。
ページの参照、編集(新規作成)、保存機能が提供されています。
私が書いたAxumによる実装は以下にあります。

# 同じ機能を実装したAxumとnet/httpのコードを見比べたときの所感
net/httpはGoが標準で提供しているパッケージでこれを素で使うことは少ないでしょうが、ginもechoもnet/httpのラッパーということなので[引用]()比較対象としては良いでしょう。

## ルーティング
net/httpでまず気になったのがパット見ハンドラがルータに紐付けられているように見えないことです。
この[記事]が非常に参考になりましたが、`DefaultServeMux`というグローバル変数が存在していて`handlerFunc`が呼ばれると`DefaultServeMux`に紐付けれるそうです。
そして、`http.ListenAndServe`の第2引数に`nil`が渡されるとサーバーに`DefaultServeMux`が渡されるという作りになっています。
知ってしまえばなんてことはないですが、私が最初にコードを見た時は少し戸惑いました。

Axumのコードはスタンダードな作りに見えます。axumはhyperのServerを再エクスポートしていて`axum::Server::bind(&"127.0.0.1:3000".parse().unwrap()).serve(app.into_make_service()).~~`というのは実際はhyperの関数を呼び出しています。hyperの`serve`関数はサービスを引数に要求するのでapp(ルーター)の`into_make_service()`関数を呼び出してサービスに変換しています。

## ミドルウェア
チュートリアルではURLのpathのバリデーションをするミドルウェアを実装する章がありました。
net/httpもaxumもハンドラに機能を付加するミドルウェアという仕組みを持っています。net/httpはミドルウェアはhandlerFuncを返す関数を引数にとり、handerFuncを返すという非常に作りになっています。
サンプルコードを見て気になったのは引数の関数のシグネチャに戻り値が書かれていないことです。これは推論されるということなのでしょうか。。

Axumはtowerのミドルウェアの仕組みをシームレスに使えるようになっています。towerにおけるハンドラとはサービスを受け取ってサービスを返すものです。
個々のハンドラーに機能を付加した場合ハンドラの`layer`関数を呼出し、ルーターに紐付けれるハンドラー全体に機能を付加したい場合はルーターの'layer'関数を呼び出します。
もともと存在するミドルウェアを使うのは簡単なのですが、ミドルウェアを自作するのは慣れが必要です。というのもサービスというのは`Future`を返す関数です。`Future`はRustで非同期を実現するためのキーとなる概念の１つです。なのでサービスをラップするにはRustの非同期の仕組みに関するある程度の知識が必要となります。例としてTimeoutミドルウェアの実装を示します。

とはいえ、独自のミドルウェアを実装したければこのような実装をしなければ行けないわけではなく、Axumにはハンドラーをミドルウェアを変換する関数が存在します。私の実装ではこれを用いました。

## エラー的なレスポンスの返し方