---
title: "Rustの特徴といいところ"
emoji: "🐥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Rust"]
published: false
---

## はじめに
Rustは魅力的な点が多すぎて、色々な人がご自身のRustの好きな点について言及します。
なのでIT初心者の方の中には「Rustのいいところって色々言われているけど結局なにが最大の特徴なの？」と思う人もいると思います。
したがってこの記事ではおそらく多くの人間が同意するであろうRustをRustたらしめている特徴とRustのいいところを紹介したいと思います。(とても陳腐な内容です。)
とはいえ私の勘違いの可能性もあるので、ご指摘があればコメント頂けると嬉しいです。

## Rustの特徴

### GCがないのにメモリ安全
世の中にはGCがあってメモリ安全な言語(Go, Java, Python,etc..)とGCがなくてメモリ安全じゃない言語(C, C++)があります。
GCがあると予測不能なタイミングでプログラムが一時停止してしまいます。多くのプログラムにおいてこの特徴は問題にならないのですが、OSやデータベース管理システム、ミドルウェアなどGCによる一時停止が許容できないソフトウェアも存在します。
そのようなソフトウェアは従来C/C++で書かれてきました。しかし、C/C++はメモリ安全性の保証がプログラマに任されているため、メモリ安全を実現できていないプログラムも多く、著名なソフトウェアにもメモリ安全性に関わるバグがたくさんあるらしいです[^1]。
GCとメモリ安全は二者択一だと思われていたのです。
そこに「GCとメモリ安全は二者択一じゃないよ」といって現れたがRustです。
Rustは所有権、借用、ライフタイムという概念を導入することで、GCなしでメモリ安全性を保証することに成功しました。
所有権、借用、ライフタイムについては以下を御覧ください。

https://doc.rust-jp.rs/rust-nomicon-ja/ownership.html

なので、本来Rustが本領発揮できる場所というのはCやC++が活躍している場所です。しかしRustは他にも魅力的な機能がたくさんあるため、別にGCがあっても良いような領域でも使う人は少なくありません。

### unsafe
Rustを使うとコンパイラがメモリ安全性を保証してくれます。
ただし、コンパイラは安全性は保証できないけど、非常に効率的に動くコードはたくさん存在します。
そのような処理を実装できなければ、Rustは非常に非効率な言語になってしまうでしょう。
そのような処理を実装したいときに使うのがunsafeという機能です。
unsafeにはunsafeブロックとunsafe関数があります。このブロック、関数の中ではunsafeな機能が使えます。(他のunsafe関数の呼び出しや生ポインタの参照解決など)
unsafeブロック、unsafe関数に書かれたコードの安全性を保証するのはプログラマの責任です。
unsafeなコードに関してはコンパイラはこう思っているといっていいでしょう。

> 「ワイ(コンパイラ)はそのコードの安全性を全く保証できないから**お前**の責任で安全性を保証しろよ。もしそれが守られなければワイが生み出すコードの動作はまったく保証できないで」

unsafeという存在があることによって、我々はコンパイラによる保証を受けながら、安全で高効率なコードが書けるという訳です。(Safe Rustに留まっている限りは)

## Rustのいいところ
このセクションではRustのいいところを説明します。このセクションで説明するものはRustの特徴で説明しているものと違って別にRust特有の機能ではありません。他の言語から拝借してきたものです。

### RAII
RAIIについては以下の記事が分かりやすいです。

https://zenn.dev/qnighy/articles/4c667de8dea5fc

Rustはスコープに基づいてリソース管理が行われていて、ある変数がスコープを抜けたとき、その変数に入っている型が`Drop`トレイト（トレイトについては後述します)を実装していれば`drop`関数が呼ばれます。
よってRustではPythonにおける`with`構文やJavaの`try-with-resources`のような専用構文を用いる必要はないのです。 



### 代数的データ型
Rustには代数的データ型があります。代数的データ型については以下の記事を御覧ください。

http://walk.northcol.org/haskell/adts/

私が思う代数的データ型のいいところは表現力がとても高いことです。
例えばjsonは代数的データ型を用いて以下のように表現できます[^2]。とても簡潔ではないでしょうか？

```rust
pub enum Value {
    Null,
    Bool(bool),
    Number(Number),
    String(String),
    Array(Vec<Value>),
    Object(Map<String, Value>),
}
```
また代数的データ型の具体例として以下のような便利なものもあります。

#### Option
Option[^3]は値を持っていないかもしれないことを表現する型です。

```rust
pub enum Option<T> {
    None,
    Some(T),
}
```

一見JavaのOptionalと似ているようですが、違います。なぜならJavaでは驚くべきことに以下のコードが有効なようなのです。Safe Rustではnullは出てきません。
RustのOptionは本当の意味で値を保持しているか否かを表す型なのですが、JavaのOptionalは値を持っていない可能性があることを明示的に表現するnullとは違った表現方式の一つにすぎません。null安全を実現するわけではないのです。

```java

Optional<Employee> employee = null; // Perfectly reasonable code!!

```

#### Result
Result[^4]はエラーなりうる型です。

```rust
enum Result<T, E> {
   Ok(T),
   Err(E),
}
```

Javaだとエラーハンドリングするためには`try-catch`で囲まなくてはなりませんが、Rustではエラーは戻り値に現れます。
慣れの問題なのかもしれませんが、個人的には関数が例外を返してくるよりResult型を返してくれたほうが圧倒的に扱いやすいです。

ある程度メジャーな非(純粋)関数型言語で代数的データ型を持っている言語はRustとScalaくらいしか私は知りません。めっちゃいい機能なのにほとんどのメジャー言語で使えないのは非常に残念です。


### trait

traitについては以下を御覧ください。
https://doc.rust-jp.rs/book-ja/ch10-02-traits.html

trait、interface、mixin、type classes界隈は正直違いが分かりづらいです。私も正確に理解できていません。Rustのtraitを説明するときに「Javaのinterfaceみたいなのものだよ」と説明する人がいます。私もそう言ってしまったことがあるのですが、実際、RustのtraitはHaskellのtype classesに近いと思います。

じゃあHaskellのtype classesとJavaのinterfaceは何が違うのかですが、以下のstack overflowの回答が参考になるかもしれません。
一番大きな違いはJavaのインターフェイスは自分のクラスにしか実装できないが、Haskellの型クラスは自分が定義したクラス以外に対しても実装できる点みたいです。
RustはOrphan ruleというものがあり、他者が定義したtraitを他者が定義したものには実装できませんが、いずれか片方が自分自身が定義したものなら実装可能です[^8]。

https://stackoverflow.com/questions/8122109/difference-between-oop-interfaces-and-fp-type-classes/8123973#8123973

traitの意味は「特性」ですがRustのtraitはまさに特性といった感じです。それを端的に示すのはマーカートレイトでこれは実装がないトレイトです。
例えば`Send`トレイトというトレイトがありこのトレイトを実装する他のスレッドに値を渡すことができるとコンパイラが判断します。逆にいうと`Send`でない値は別のスレッドに渡すことができません。

個人的にtraitのいいなあと思う点は色々なクレート間でtraitを共通認識として用いることができることです。
例えば[axum](https://docs.rs/axum/latest/axum/)というWebフレームワークと[hyper](https://hyper.rs/)というHTTPサーバ機能を提供するクレートがあるのですが、両者の間では[tower](https://docs.rs/tower/latest/tower/)のServiceトレイトを実装したものが渡されることが期待されています。こうすることでaxumはhyperをデフォルトで用いるのですが、Serviceを適切に処理してくれるものならhyperでなくても良く、hyperもサービスを渡してくれるならaxum以外も受け入れられるといったmodularityを獲得しています。

### macro
Rustはマクロが使えます。マクロはコンパイルの際に型チェックより前に展開されるため、すごくパワフルなことがいろいろできます。

例えばaxumでは以下のようなマクロがありました。

```rust
macro_rules! impl_handler {
    ( $($ty:ident),* $(,)? ) => {
        #[allow(non_snake_case)]
        impl<F, Fut, B, Res, $($ty,)*> Handler<($($ty,)*), B> for F
        where
            F: FnOnce($($ty,)*) -> Fut + Clone + Send + 'static,
            Fut: Future<Output = Res> + Send,
            B: Send + 'static,
            Res: IntoResponse,
            $( $ty: FromRequest<B> + Send,)*
        {
            type Future = Pin<Box<dyn Future<Output = Response> + Send>>;

            fn call(self, req: Request<B>) -> Self::Future {
                Box::pin(async move {
                    let mut req = RequestParts::new(req);

                    $(
                        let $ty = match $ty::from_request(&mut req).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
                    )*

                    let res = self($($ty,)*).await;

                    res.into_response()
                })
            }
        }
    };
}


all_the_tuples!(impl_handler);

macro_rules! all_the_tuples {
    ($name:ident) => {
        $name!(T1);
        $name!(T1, T2);
        $name!(T1, T2, T3);
        $name!(T1, T2, T3, T4);
        $name!(T1, T2, T3, T4, T5);
        $name!(T1, T2, T3, T4, T5, T6);
        $name!(T1, T2, T3, T4, T5, T6, T7);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
    };

```

細かいことは省きますが、ここでは` FnOnce($($ty,)*) -> Fut + Clone + Send + 'static`という制約を満たす引数が1～16個の関数について(引数に制約がありますが省略します)Handlerトレイトを実装しています。マクロ無しでこんなことをやるのは難しそうです。

後よく分かりませんが、Rustのマクロは`partially hygienic`だそうです[^7]。

hygienic macroについては以下を御覧ください。
https://ja.wikipedia.org/wiki/%E5%81%A5%E5%85%A8%E3%81%AA%E3%83%9E%E3%82%AF%E3%83%AD

## おわりに
この記事ではRustの特徴といいところを紹介しました。
とはいえ私はITエンジニアとしてのレベルが相当低いため[^5]、Rustが好きなのはGCがないのが主な理由ではなく、主にトレイト、ジェネリクス、代数的データ型、パターンマッチ、マクロなどクールな機能がたくさん入っていることが理由です。
所有権、参照、ライフタイムは書いていてたまに苦しむので、GCがあってもいい場面ではGC付きRustみたいなものが欲しいなあと思います(それはRustではない)




## 参考文献
https://www.oreilly.co.jp/books/9784873119786/

[^1]:https://www.chromium.org/Home/chromium-security/memory-safety/
[^2]:https://docs.serde.rs/serde_json/value/enum.Value.html
[^3]:https://doc.rust-lang.org/std/option/enum.Option.html
[^4]:https://doc.rust-lang.org/std/result/enum.Result.html
[^5]:この事実に対して恥じる気持ちと今後改善していきたい思いはあります。
[^6]:https://www.reddit.com/r/rust/comments/cn20vu/traits_vs_interfaces/
[^7]:https://danielkeep.github.io/tlborm/book/mbe-min-hygiene.html
[^8]:https://rust-lang.github.io/chalk/book/clauses/coherence.html