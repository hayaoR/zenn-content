---
title: "Rustの特徴といいところ"
emoji: "🐥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Rust"]
published: false
---

## はじめに
Rustは魅力的な点が多すぎて、色々な人がご自身のRustの好きな点について言及します。
なのでIT初心者の方の中には「Rustのいいところって色々言われているけど結局なにが最大の特徴なの？」と思う人もいると思います。
したがってこの記事ではおそらく多くの人間が同意するであろうRustをRustたらしめている特徴とRustのいいところを紹介したいと思います。(とても陳腐な内容です。)
とはいえ間違っていることもたくさん書いてしまっていると思うので、ご指摘があればコメント頂けると嬉しいです。

## Rustの特徴
このセクションはRustのおそらくユニークと思われる特徴を紹介します。

### GCがないのにメモリ安全
世の中には[GC](https://ja.wikipedia.org/wiki/%E3%82%AC%E3%83%99%E3%83%BC%E3%82%B8%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3)があって[メモリ安全](https://ja.wikipedia.org/wiki/%E3%83%A1%E3%83%A2%E3%83%AA%E5%AE%89%E5%85%A8%E6%80%A7)な言語(Go, Java, Python,etc..)とGCがなくてメモリ安全じゃない言語(C, C++)があります。
GCがあると予測不能なタイミングでプログラムが一時停止してしまいます。多くのプログラムにおいてこの特徴は問題にならないのですが、OSやデータベース管理システム、ミドルウェアなどGCによる一時停止が許容できないソフトウェアも存在します。
そのようなソフトウェアは従来C/C++で書かれてきました。しかし、C/C++はメモリ安全性の保証がプログラマに任されているため、メモリ安全を実現できていないプログラムも多く、著名なソフトウェアにもメモリ安全性に関わるバグがたくさんあるらしいです[^1]。

さて、これまでGCとメモリ安全は二者択一だと思われてきました。
そこに「GCとメモリ安全は二者択一じゃないよ」といって現れたのがRustです。
Rustは所有権、借用、ライフタイムという概念を導入することで、GCなしでメモリ安全性を保証することに成功しました。
所有権、借用、ライフタイムについては以下を御覧ください。

https://doc.rust-jp.rs/rust-nomicon-ja/ownership.html

なので、本来Rustが本領発揮できる場所というのはCやC++が活躍している場所です。しかしRustは他にも魅力的な機能がたくさんあるため、別にGCがあっても良いような領域でも使う人は少なくありません。

### unsafe
Rustを使うとコンパイラがメモリ安全性を保証してくれます。
ただし、コンパイラは安全性は保証できないけど、非常に効率的に動くコードはたくさん存在します。
そのような処理を実装できなければ、Rustは非常に非効率な言語になってしまうでしょう。
そのような処理を実装したいときに使うのがunsafeという機能です。
unsafeにはunsafeブロックとunsafe関数があります。このブロック、関数の中ではunsafeな機能が使えます。(他のunsafe関数の呼び出しや生ポインタの参照解決など)
unsafeブロック、unsafe関数に書かれたコードの安全性を保証するのはプログラマの責任です。
unsafeなコードに関してはコンパイラはこう思っているといっていいでしょう。

> 「ワイ(コンパイラ)はそのコードの安全性を全く保証できないから**お前**の責任で安全性を保証しろよ。もしそれが守られなければワイが生み出すコードの動作はまったく保証できないで」

unsafeという存在があることによって、我々はコンパイラによる保証を受けながら、安全で高効率なコードが書けるという訳です。(Safe Rustに留まっている限りは)

## Rustのいいところ
このセクションではRustのいいところを説明します。このセクションで説明するものはRustの特徴で説明しているものと違って別にRust特有の機能ではありません。他の言語から拝借してきたものです。
機能自体を説明すると記事が長くなってしまうので、機能自体の説明は他の記事にまかせています。

### RAII
RAIIについては以下をご覧ください。

https://ja.wikipedia.org/wiki/RAII


Rustはスコープに基づいたリソース管理が行われていて、ある変数がスコープを抜けたとき、その変数の値が`Drop`トレイト（traitについては後述します)を実装していれば`drop`関数が呼ばれます。
よってRustではリソース管理においてPythonにおける`with`構文やJavaの`try-with-resources`のような専用構文を用いる必要はないのです。 



### 代数的データ型
Rustには代数的データ型があります。代数的データ型については以下の記事を御覧ください。

http://walk.northcol.org/haskell/adts/

私が思う代数的データ型のいいところは表現力がとても高いことです。
例えばjsonは代数的データ型を用いて以下のように表現できます[^2]。とても簡潔ではないでしょうか？

```rust
pub enum Value {
    Null,
    Bool(bool),
    Number(Number),
    String(String),
    Array(Vec<Value>),
    Object(Map<String, Value>),
}
```
また代数的データ型の具体例として以下のような便利なものもあります。

#### Option
[Option](https://doc.rust-lang.org/std/option/enum.Option.html)は値を持っていないかもしれないことを表現する型です。

```rust
pub enum Option<T> {
    None,
    Some(T),
}
```

一見JavaのOptionalと似ているようですが、違います。なぜならJavaでは驚くべきことに以下のコードが有効なようなのです。Safe Rustではnullは出てきません。

```java

Optional<Employee> employee = null; // Perfectly reasonable code!!

```

RustのOptionは本当の意味で値を保持しているか否かを表す型なのですが（=null安全を実現している）、JavaのOptionalは値を持っていない可能性があることを明示的に表現する方式の一つにすぎません。null安全を実現するわけではないのです。


#### Result
[Result](https://doc.rust-lang.org/std/result/enum.Result.html)はエラーになりうる型です。

```rust
enum Result<T, E> {
   Ok(T),
   Err(E),
}
```

Javaだとエラーハンドリングするためには`try-catch`で囲まなくてはなりませんが、Rustではエラーは戻り値に現れます。
慣れの問題なのかもしれませんが、個人的には関数が例外を返してくるよりResult型を返してくれたほうが圧倒的に扱いやすいです。

ある程度メジャーな非純粋関数型言語で代数的データ型を持っている言語はRustとScalaくらいしか私は知りません。めっちゃいい機能なのにほとんどのメジャー言語で使えないのは非常に残念です。


### trait

traitについては以下を御覧ください。
https://doc.rust-jp.rs/book-ja/ch10-02-traits.html

trait、interface、mixin、type classes界隈は正直違いが分かりづらいです。私も正確に理解できていません。Rustのtraitを説明するときに「Javaのinterfaceみたいなのものだよ」と説明する人がいます。間違いではないと思いますし、私もそう言ってしまったことがあるのですが、実際、RustのtraitはHaskellのtype classesに近いと思います。

「じゃあHaskellのtype classesとJavaのinterfaceは何が違うのか」という話になりますすが、以下のstack overflowの回答が参考になるかもしれません。

https://stackoverflow.com/questions/8122109/difference-between-oop-interfaces-and-fp-type-classes/8123973#8123973

まず概念的な話でいうと、Haskellのtype classesは型を分類するものです[^9]。一方、Javaのinterfaceはメソッドの集まりで契約を形成します[^5]。

実用上の違いでいうと、Javaのinterfaceは自分のクラスにしか実装できませんが、Haskellのtype classesは自分が定義した型以外に対しても実装できます。
RustのtraitにはOrphan ruleというものがあり、外部で定義されたtraitを外部で定義された型には実装できませんが、いずれか片方が自分自身が定義したものなら実装可能です[^8]。

#### Rustのtrait
traitの意味は「特性」ですがRustのtraitはまさに特性といった感じです。それを端的に示すのは[marker trait](https://doc.rust-lang.org/std/marker/index.html)です。marker traitは実装がないtraitでコンパイラが動作を判断するのに使われます。
例えば`Send`トレイトというmarker traitがありこのtraitはその型（の値）を他のスレッドに渡すことができる場合に自動で実装されます。したがって`Send`を実装する型は（当然）他のスレッドに渡すことができるとコンパイラが判断します。逆にいうと`Send`でない型は別のスレッドに渡すことができません。

#### traitの好きな点
個人的にtraitのよいと思う点は色々な[クレート](https://doc.rust-jp.rs/book-ja/ch07-01-packages-and-crates.html)間でtraitを共通認識として用いることができることです。
例えば[axum](https://docs.rs/axum/latest/axum/)というWebフレームワークと[hyper](https://hyper.rs/)というHTTPサーバ機能を提供するライブラリがあるのですが、両者の間では[tower](https://docs.rs/tower/latest/tower/)の`Service`トレイトを実装したものが渡されることが期待されています。こうすることでaxumはhyperをデフォルトで用いるのですが、`Service`を適切に処理してくれるものならhyperでなくても良く、hyperも`Service`を渡してくれるならaxum以外も受け入れられるといったmodularityを獲得しています。(「それ[ストラテジーパターン](https://ja.wikipedia.org/wiki/Strategy_%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3)のことだよね？」と言われるとそうなのかもしれません。。)

## macro
Rustはmacroが使えます。macroはコンパイルの際に初期の段階で展開されるため、すごくパワフルなことがいろいろできます。

例えばaxumでは以下のようなmacroがありました。

```rust
macro_rules! impl_handler {
    ( $($ty:ident),* $(,)? ) => {
        #[allow(non_snake_case)]
        impl<F, Fut, B, Res, $($ty,)*> Handler<($($ty,)*), B> for F
        where
            F: FnOnce($($ty,)*) -> Fut + Clone + Send + 'static,
            Fut: Future<Output = Res> + Send,
            B: Send + 'static,
            Res: IntoResponse,
            $( $ty: FromRequest<B> + Send,)*
        {
            type Future = Pin<Box<dyn Future<Output = Response> + Send>>;

            fn call(self, req: Request<B>) -> Self::Future {
                Box::pin(async move {
                    let mut req = RequestParts::new(req);

                    $(
                        let $ty = match $ty::from_request(&mut req).await {
                            Ok(value) => value,
                            Err(rejection) => return rejection.into_response(),
                        };
                    )*

                    let res = self($($ty,)*).await;

                    res.into_response()
                })
            }
        }
    };
}


all_the_tuples!(impl_handler);

macro_rules! all_the_tuples {
    ($name:ident) => {
        $name!(T1);
        $name!(T1, T2);
        $name!(T1, T2, T3);
        $name!(T1, T2, T3, T4);
        $name!(T1, T2, T3, T4, T5);
        $name!(T1, T2, T3, T4, T5, T6);
        $name!(T1, T2, T3, T4, T5, T6, T7);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15);
        $name!(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16);
    };

```

細かいことは省きますが、ここではwhere句の制約を満たす引数が1～16個の関数についてHandlerトレイトを実装しています。macro無しでこんなことをやるのは難しそうです。

後よく分かりませんが、Rustのmacroは`partially hygienic`だそうです[^7]。

hygienic macroについては以下を御覧ください。
https://ja.wikipedia.org/wiki/%E5%81%A5%E5%85%A8%E3%81%AA%E3%83%9E%E3%82%AF%E3%83%AD

## おわりに
この記事ではRustの特徴といいところを紹介しました。
上記であげたような機能の存在により、Rustはコンパイラがプログラムを正しく書くことを助けてくれます[^3]。そういう意味で（私のような）おバカな人間にピッタリのプログラミング言語と言えます。
一方でRustは習得するのが難しい言語です。つまりおバカな人間ほどRustを使うご利益が大きいのに、難しくて習得できないというジレンマが存在するのです。（おバカじゃなくても人間はうっかりミスをするものなので、Rustを使う価値はあると思いますが）
Rust communityもこの問題を認識しているようで、Rust Edition 2024のロードマップでは目標の一つに「学習曲線を平坦化する」というものが挙げられています[^4]。
それでも習得は難しいとは思いますが、Rustは良いプログラムを書く上で大きな力になってくれると思うので、ぜひ皆さんにも習得頂けると嬉しいです！




## 参考文献
https://www.oreilly.co.jp/books/9784873119786/

[^1]:https://www.chromium.org/Home/chromium-security/memory-safety/
[^2]:https://docs.serde.rs/serde_json/value/enum.Value.html
[^3]:https://kerkour.com/bugs-rust-compiler-helps-prevent
[^4]:https://blog.rust-lang.org/inside-rust/2022/04/04/lang-roadmap-2024.html
[^5]:https://docs.oracle.com/javase/tutorial/java/concepts/interface.html
[^6]:https://www.reddit.com/r/rust/comments/cn20vu/traits_vs_interfaces/
[^7]:https://danielkeep.github.io/tlborm/book/mbe-min-hygiene.html
[^8]:https://rust-lang.github.io/chalk/book/clauses/coherence.html
[^9]:http://walk.northcol.org/haskell/type-classes/
